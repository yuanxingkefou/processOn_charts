{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","title":"Java集合类","leftChildren":[],"structure":"mind_right","root":true,"theme":"colorLines","children":[{"id":"1583019abfa1","title":"Collection","parent":"root","children":[{"id":"8369c9630732","title":"List","parent":"1583019abfa1","children":[{"id":"0a4a69405b36","title":"AbstractList","parent":"8369c9630732","children":[{"id":"ec5a691ca8be","title":"ArrayList","children":[{"id":"5b304c407edb","title":"底层是数组实现,遍历方便,但插入和删除复杂","children":[],"parent":"ec5a691ca8be"},{"id":"79e77ffcd607","title":"add时,首先判断是否存在该数组,如果不存在的话,先初始化一个给定容量的数组.然后判断插入后数组的大小是否够,不够的话,进行扩容,扩容时,首先检查数组大小是否以及达到最大值,然后进行扩容,最后将元素插入","children":[],"parent":"ec5a691ca8be"},{"id":"8fbd017f9140","title":"初始容量为10,每次扩容时,扩容为原来的1.5倍,扩容采用的是System.arraycopy()方法,底层是c/c++实现的naive方法","children":[],"parent":"ec5a691ca8be"},{"id":"c92e3f57e7aa","title":"多线程情况下,不能保持同步","children":[],"parent":"ec5a691ca8be"}],"parent":"0a4a69405b36"},{"id":"c852b36b8522","title":"Vector","children":[{"id":"48130bdb2c94","title":"多线程情况下,可以保证同步","children":[],"parent":"c852b36b8522"},{"id":"007ebe03d5c0","title":"初始容量为10,每次扩容为原来的2倍","children":[],"parent":"c852b36b8522"}],"parent":"0a4a69405b36"}]}]},{"id":"ab76603d3f6a","title":"Queue","parent":"1583019abfa1","children":[{"id":"12650f1f643c","title":"Deque","parent":"ab76603d3f6a","children":[{"id":"557b0c434e93","title":"AbstractSequentialList","children":[{"id":"f2b8637bd856","title":"LinkedList","children":[{"id":"dfca85822807","title":"底层是由双向链表实现,遍历复杂,但插入和删除简单","children":[],"parent":"f2b8637bd856"},{"id":"dc1b7b6dee00","title":"用作栈的方法有:push和pop()","parent":"f2b8637bd856","children":[]},{"id":"429246eb70ed","title":"用作队列的方法有offer(),peek()poll()","parent":"f2b8637bd856","children":[]},{"id":"172083dd7e23","title":"其他还有add,addFirst,removeFirst,removeLast等","children":[],"parent":"f2b8637bd856"}],"parent":"557b0c434e93"}],"parent":"12650f1f643c"}]},{"id":"bc10fdeec1b1","title":"AbstractQueue","parent":"ab76603d3f6a","children":[{"id":"ce5cd24d6c6f","title":"PriorityQueue","children":[{"id":"07cc0c349aa5","title":"底层是由堆实现的,默认为最小堆","parent":"ce5cd24d6c6f","children":[]}],"parent":"bc10fdeec1b1"}]}]},{"id":"d8d293225c35","title":"Set","parent":"1583019abfa1","children":[{"id":"b89ba7980bba","title":"AbstractSet","parent":"d8d293225c35","children":[{"id":"d1cf605fafcd","title":"HashSet","parent":"b89ba7980bba","children":[{"id":"a76c26af5e9b","title":"底层是由HashMap实现,存储的是key键,值为默认的一个对象","parent":"d1cf605fafcd","children":[]}]}]},{"id":"5c5ecda1ecdc","title":"SortedSet","parent":"d8d293225c35","children":[{"id":"b33245f9e767","title":"TreeSet","children":[{"id":"a7c6f5fc90ca","title":"红黑树实现的一个有序集合","parent":"b33245f9e767","children":[]}],"parent":"5c5ecda1ecdc"}]}]}]},{"id":"c99cc1e80963","title":"Map&lt;K,V&gt;","parent":"root","children":[{"id":"dacff305a638","title":"AbstractMap","parent":"c99cc1e80963","children":[{"id":"4d5c362eef90","title":"HashMap","children":[{"id":"246b17008c8f","title":"hash方法","parent":"4d5c362eef90","children":[{"id":"a2fed12c66c9","title":"hash=(h=key.hashcode())^(h&gt;&gt;&gt;16)<br>hash&amp;(n-1)(和长度的后n-1位进行hash)","children":[],"parent":"246b17008c8f"},{"id":"c123b08aaf80","title":"解决HASH冲突的办法","parent":"246b17008c8f","children":[{"id":"591ff6169e5d","title":"开放定址法","parent":"c123b08aaf80","children":[{"id":"f25d8a27708e","title":"线性探测法","parent":"591ff6169e5d","children":[]},{"id":"b97db05e86e3","title":"线性补偿探测法","children":[],"parent":"591ff6169e5d"},{"id":"ec532bcbbe53","title":"随机探测","children":[],"parent":"591ff6169e5d"}]},{"id":"7f29ce0d551d","title":"再Hash法","parent":"c123b08aaf80","children":[]},{"id":"e907c03f1c64","title":"拉链法","parent":"c123b08aaf80","children":[]},{"id":"1272524246f5","title":"建立公共溢出区","parent":"c123b08aaf80","children":[]}]}]},{"id":"3c6e0684209d","title":"get()","children":[{"id":"09c96798a612","title":"判断table是否为空，所对应的地址是否有值，如果不满足的话，返回null","children":[],"parent":"3c6e0684209d"},{"id":"56f86a632d5b","title":"根据得到的地址，总是查询桶里第一个值，如果满足的话，返回，否则循环查看，判断是否为树节点，如果是的话，按照树节点的方式查询","children":[],"parent":"3c6e0684209d"}],"parent":"4d5c362eef90"},{"id":"1b32dac16bba","title":"put()","children":[{"id":"5dede812b890","title":"判断table是否为空，如果为空，则扩容","children":[],"parent":"1b32dac16bba"},{"id":"b7618be70686","title":"判断node所对应的位置是否为空，如果为空，则创建新的节点并指向","children":[],"parent":"1b32dac16bba"},{"id":"cb9ed44cea83","title":"如果不为空，查询桶的第一个值的hash和vkey是否 满足，如果满足，修改valve的值","children":[],"parent":"1b32dac16bba"},{"id":"7e1136bef0cd","title":"如果不满足，则循环查看，如果是树节点的话，按照树节点来查看","children":[],"parent":"1b32dac16bba"},{"id":"545d681d8bdb","title":"如果最后一个都不满足的话，则将node节点插入到尾端","children":[],"parent":"1b32dac16bba"},{"id":"047bce59dc9a","title":"如果链表长度大于树化因子，则转换为树","children":[],"parent":"1b32dac16bba"}],"parent":"4d5c362eef90"},{"id":"8b7c7845247b","title":"底层实现是数组+链表+红黑树","children":[{"id":"fce4857d3c33","title":"当链表的长度达到8时,进行树化；反过来,当链表的长度减到6时,树转换为链表","parent":"8b7c7845247b","children":[]}],"parent":"4d5c362eef90"},{"id":"33280c31576e","title":"初始容量为16,如果输入自定义的容量,会转换成比它小的最近的2的次幂,当容量达到初始容量*扩容因子时,进行扩容","children":[],"parent":"4d5c362eef90"},{"id":"5eead4a71c22","title":"LinkedHashMap","parent":"4d5c362eef90","children":[{"id":"5e703a09837f","title":"相对于HashMap来说,添加了双向指针before和after,用来进行排序,构造其中有一个属性accessOrder,默认为false,根据插入的顺序进行排序,当为true时,采用LRU算法的顺序","parent":"5eead4a71c22","children":[]}]},{"id":"b0d2836c3fc8","title":"ConcurrentHashMap","parent":"4d5c362eef90","children":[{"id":"18cff111515a","title":"jdk1.7以前,采用分段锁的思想","children":[],"parent":"b0d2836c3fc8"},{"id":"e29e07bba6f9","title":"jdk1.8后采用CAS算法来保证同步","children":[{"id":"8283b6775cd7","title":"get方法无锁,采用volatile关键字来实现","children":[],"parent":"e29e07bba6f9"}],"parent":"b0d2836c3fc8"},{"id":"fc32a5681742","title":"扩容时采取并发扩容的思想","parent":"b0d2836c3fc8","children":[{"id":"9476d4c9eb88","title":"将表拆分,每个表分得16个桶,然后进行扩容,因为扩容是容量变为原来的两倍,长度n*2,hash算法中相当于和后n位hash,多的一位只可能是0或1,所以rehash时只需要将每个链表分成两个新的链表,分别放到为1和为0的桶中","parent":"fc32a5681742","children":[]}]}]}],"parent":"dacff305a638"}]},{"id":"1b61a59d63be","title":"SortedMap","parent":"c99cc1e80963","children":[{"id":"5160ad76c61b","title":"TreeMap","children":[{"id":"2ebd0c867648","title":"底层是LinkedHashMap","children":[],"parent":"5160ad76c61b"}],"parent":"1b61a59d63be"}]}]},{"id":"197540ec1d24","title":"Iterator","parent":"root","children":[{"id":"86529a7da270","title":"hasNext","children":[],"parent":"197540ec1d24"},{"id":"05d176055073","title":"next","children":[],"parent":"197540ec1d24"},{"id":"8a9ff732a0e6","title":"remove","children":[{"id":"5cb204e2f0a8","title":"fail-fast机制","children":[{"id":"7f1f78a64284","title":"防止并发的修改数据,在使用iterator前会保留一个expectedModcount值,当进行修改时,会和modCount进行比较,如果不相同的话,就会抛出并发修改的异常,","parent":"5cb204e2f0a8","children":[]}],"parent":"8a9ff732a0e6"},{"id":"736524b38cc4","title":"safe-fast机制","children":[{"id":"2f31259a9f81","title":"同步的集合中,因为使用了synchronized关键字,所以不需要使用fail-fast机制,是可以安全修改的","parent":"736524b38cc4","children":[]}],"parent":"8a9ff732a0e6"}],"parent":"197540ec1d24"}]}],"lines":{"685d785d5d0e":{"to":"0a4a69405b36","id":"685d785d5d0e","realStart":{"y":9550.5,"x":10691.71875},"start":{"index":1,"y":"0.2","x":"0.0"},"realEnd":{"y":9381.5,"x":10483.078125},"styles":{"lineColor":"rgb(113, 203, 45)","color":"#ffffff","lineWidth":2},"label":"extends","points":[{"y":9681.225,"x":10583.359375},{"y":9682.975,"x":10591.4375}],"from":"f2b8637bd856","angle":70.23000422869163,"end":{"index":3,"y":"0.8","x":"1.0"},"pts":[{"y":123.22500000000036,"x":-148.359375},{"y":308.97500000000036,"x":153.859375}]}}}},"meta":{"id":"5c94dfb9e4b0c996d36e08b0","member":"5c94c2a6e4b02ce2e8992267","exportTime":"2019-12-03 20:02:55","diagramInfo":{"category":"mind_free","title":"Java集合类","created":"2019-03-22 21:14:33","creator":"5c94c2a6e4b02ce2e8992267","modified":"2019-04-19 10:03:44"},"type":"ProcessOn Schema File","version":"1.0"}}