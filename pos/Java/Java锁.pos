{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","title":"Java锁","leftChildren":[{"id":"cd87ea3d2d1e","title":"线程池","parent":"root","children":[{"id":"9c707a389d16","title":"Executor","children":[{"id":"894f0eed454f","title":"execute方法","children":[],"parent":"9c707a389d16"}],"parent":"cd87ea3d2d1e"},{"id":"023807b8a903","title":"Callable","children":[{"id":"18fa2949ff99","title":"可以实现有返回值的线程","children":[],"parent":"023807b8a903"}],"parent":"cd87ea3d2d1e"},{"id":"37eb809f0f9c","title":"Future","children":[{"id":"8112d299b044","title":"用来保存线程的返回值","children":[],"parent":"37eb809f0f9c"},{"id":"7a2faedc5e24","title":"FutureTask&lt;Integer&gt; test=new FutureTask&lt;&gt;(new Callable());<br>int result=test.get();","children":[],"parent":"37eb809f0f9c"}],"parent":"cd87ea3d2d1e"},{"id":"9b4abdb54bc1","title":"分类","parent":"cd87ea3d2d1e","children":[{"id":"e503aebe282f","title":"ThreadPoolExecutor","parent":"9b4abdb54bc1","children":[{"id":"42fdb55eb3f9","title":"Executors.newFixedThreadPool();","parent":"e503aebe282f","children":[]},{"id":"decf0d3f9c77","title":"Executors.newCachedThreadPool();","parent":"e503aebe282f","children":[]},{"id":"fb3edf274f07","title":"Executors.newSIngleThreadPool();","parent":"e503aebe282f","children":[]},{"id":"91f8e775e7ac","title":"Executors.newScheduledThreadPool();","parent":"e503aebe282f","children":[]},{"id":"90357dc4d344","title":"属性：corePoolSize,maxPoolSize,keepAliveTime,TimeUnit,BlockingQueue,RejectedExecutionHandler","parent":"e503aebe282f","children":[]}]},{"id":"db2df9905478","title":"new ForkAndJoin()","parent":"9b4abdb54bc1","children":[{"id":"48d607b30692","title":"工作窃取算法","parent":"db2df9905478","children":[]},{"id":"bf8790412540","title":"new WordStealingPool();","parent":"db2df9905478","children":[]}]}]},{"id":"f36f936f47ca","title":"状态","parent":"cd87ea3d2d1e","children":[{"id":"bdf278616b2e","title":"Running","parent":"f36f936f47ca","children":[]},{"id":"5216a1b1e955","title":"Shutting Down","parent":"f36f936f47ca","children":[]},{"id":"95641b2d005c","title":"stop","parent":"f36f936f47ca","children":[]},{"id":"d198698cf09d","title":"TIDY ing","parent":"f36f936f47ca","children":[]},{"id":"da64c729ef07","title":"Terminated","parent":"f36f936f47ca","children":[]}]},{"id":"9edad09c78c9","title":"流程","parent":"cd87ea3d2d1e","children":[{"id":"ae128946382a","title":"如果核心池没有满的话，先在核心池中添加线程，如果核心池满的话，但还没有达到最大线程值，就将线程放到阻塞队列中，如果达到最大值，就执行拒绝策略","parent":"9edad09c78c9","children":[]}]},{"id":"e6f9d40aa076","title":"拒绝策略","parent":"cd87ea3d2d1e","children":[{"id":"a4f5960985f7","title":"ThreadPoolExecutor.AbortPolicy()","parent":"e6f9d40aa076","children":[]},{"id":"dfb03b16ed9c","title":"ThreadPoolExecutor.CallerRunsPlicy()","parent":"e6f9d40aa076","children":[]},{"id":"ec51197cf8d7","title":"ThreadPoolExecutor.DiscardOlderPolicy()","parent":"e6f9d40aa076","children":[]},{"id":"84c921311479","title":"ThreadPoolExecutor.DiscardPolicy()","parent":"e6f9d40aa076","children":[]}]}]}],"structure":"mind_free","root":true,"theme":"colorLines","children":[{"id":"b98450056fbc","title":"协作","parent":"root","children":[{"id":"5fe3ba3118c5","title":"Semaphore","children":[{"id":"b93ed3d1e508","title":"控制同时访问线程的个数","children":[],"parent":"5fe3ba3118c5"}],"parent":"b98450056fbc"},{"id":"1b85f1671316","title":"Monitor","children":[],"parent":"b98450056fbc"},{"id":"c75e4e5fb45a","title":"CountDownLatch","children":[{"id":"ad8c0faf18f6","title":"可以起到计数器的作用","children":[],"parent":"c75e4e5fb45a"}],"parent":"b98450056fbc"},{"id":"4e4a5a0803fe","title":"CyclicBarrier","children":[{"id":"2b82e82ab534","title":"规定所有的线程都到达一个barrier状态后，再一起进行下一个任务","children":[],"parent":"4e4a5a0803fe"}],"parent":"b98450056fbc"},{"id":"f516ac2330db","title":"Phaser","children":[],"parent":"b98450056fbc"},{"id":"6684592ff12e","title":"Exchanger","children":[],"parent":"b98450056fbc"},{"id":"7bdf403bf165","title":"ThreadLocal","children":[{"id":"3044e1ceeeeb","title":"以空间换时间，维护了一个map表，为每个线程保存了一个该线程的本地变量","children":[],"parent":"7bdf403bf165"},{"id":"d5e9ab119134","title":"主要引用：数据库链接，session管理","children":[],"parent":"7bdf403bf165"}],"parent":"b98450056fbc"},{"id":"26ccb2ce021e","title":"volatile关键字","parent":"b98450056fbc","children":[{"id":"a41822a086b4","title":"只能保证可见性，不能保证原子性","parent":"26ccb2ce021e","children":[]},{"id":"2c48d20ee871","title":"原理：通过内存屏障，使每个线程在访问值的时候都访问放在内存中的值，而不是自己保存的对象副本中的值，修改时，也是直接将值写入内存中，这样所有的线程就可以看到","parent":"26ccb2ce021e","children":[]},{"id":"f6dd4b028033","title":"因为synchronized已经进行过优化，所以效率并不会提升多少，一般主要用来避免指令重排序","children":[],"parent":"26ccb2ce021e"}]}]},{"id":"3d633ba5983e","title":"AbstractQueuedSynchronized","children":[{"id":"0d89fdd31aaf","title":"State用来表示状态，初始化为0，每加一次锁，就+1","children":[],"parent":"3d633ba5983e"},{"id":"e757620fa728","title":"CLH队列：用来存放等待的线程","children":[],"parent":"3d633ba5983e"},{"id":"70c5e5ec01b2","title":"两种方式","children":[{"id":"7ef31e91d736","title":"Exclusive","children":[{"id":"c60be61dcd7e","title":"ReentrantLock","children":[{"id":"2d40ab50d253","title":"tryAcquire(1);","children":[],"parent":"c60be61dcd7e"}],"parent":"7ef31e91d736"}],"parent":"70c5e5ec01b2"},{"id":"99b4e8bf364c","title":"Share","children":[{"id":"c62c40bd69f8","title":"Semaphore","children":[],"parent":"99b4e8bf364c"},{"id":"35ff616add5e","title":"CountDownLatch","children":[],"parent":"99b4e8bf364c"}],"parent":"70c5e5ec01b2"}],"parent":"3d633ba5983e"}],"parent":"root"},{"id":"6121c5370af8","title":"互斥","parent":"root","children":[{"id":"8ff675356db7","title":"无锁","parent":"6121c5370af8","children":[{"id":"9716e798246a","title":"CAS","parent":"8ff675356db7","children":[]},{"id":"dd65b069293f","title":"原子类","parent":"8ff675356db7","children":[]}]},{"id":"d9fe344bc1cc","title":"互斥锁","parent":"6121c5370af8","children":[{"id":"ce34fec853f4","title":"Synchronized","parent":"d9fe344bc1cc","children":[{"id":"b081cb318ff6","title":"可以修饰代码块，对象，类","parent":"ce34fec853f4","children":[]},{"id":"da74b0a40b19","title":"不需要手动加锁，遇到异常时，会自动释放锁","parent":"ce34fec853f4","children":[]},{"id":"5eabe7db4e65","title":"新特性","parent":"ce34fec853f4","children":[{"id":"77feceb7c79f","title":"锁消除","parent":"5eabe7db4e65","children":[]},{"id":"f65636b3a62e","title":"自旋锁","parent":"5eabe7db4e65","children":[]},{"id":"8adb76b7fbb9","title":"偏向锁","parent":"5eabe7db4e65","children":[]},{"id":"69bade1fc452","title":"轻量级锁","parent":"5eabe7db4e65","children":[]},{"id":"4f431b808e25","title":"重量级锁","parent":"5eabe7db4e65","children":[]}]}]},{"id":"46bfebc78e3c","title":"Lock","parent":"d9fe344bc1cc","children":[{"id":"d6400465862d","title":"ReentrantLock","parent":"46bfebc78e3c","children":[{"id":"370ce7bee455","title":"只能修饰代码块，但更加灵活","parent":"d6400465862d","children":[]},{"id":"2d01da6bd343","title":"需要手动加锁，释放锁，一般是在try语句之前加锁,finalize中释放锁","parent":"d6400465862d","children":[]},{"id":"a5bcf6e0bc08","title":"可以和条件对象Condition相互配合","parent":"d6400465862d","children":[]}]},{"id":"89dd66dd8fce","title":"读写锁","parent":"46bfebc78e3c","children":[{"id":"26af13ec360e","title":"读不加锁，写加锁","parent":"89dd66dd8fce","children":[]},{"id":"718e434d5261","title":"读锁不能升级为写锁，但写锁可以降级为读锁","parent":"89dd66dd8fce","children":[]},{"id":"5a761062fd42","title":"原理：State变量中的高16位为读锁，低16位为写锁","parent":"89dd66dd8fce","children":[]}]}]}]}]}]}},"meta":{"id":"5c94ea27e4b09a16b9ad48ea","member":"5c94c2a6e4b02ce2e8992267","exportTime":"2019-12-03 20:03:25","diagramInfo":{"category":"mind_free","title":"Java锁","created":"2019-03-22 21:59:03","creator":"5c94c2a6e4b02ce2e8992267","modified":"2019-03-23 10:07:14"},"type":"ProcessOn Schema File","version":"1.0"}}