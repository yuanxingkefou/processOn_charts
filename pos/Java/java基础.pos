{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","title":"Java基础","leftChildren":[{"id":"07a5d617bbd0","title":"IO","parent":"root","children":[{"id":"ba6c41f4a5b1","title":"BIO","children":[],"parent":"07a5d617bbd0"},{"id":"c325cbc278d6","title":"NIO","children":[],"parent":"07a5d617bbd0"},{"id":"c66b8ed12ebc","title":"AIO","children":[],"parent":"07a5d617bbd0"}]},{"id":"64c99878bc4e","title":"基础数据类型","children":[{"id":"2f3f452bf8df","title":"boolean","children":[{"id":"d287b80c2564","title":"1位,只有true和false","children":[],"parent":"2f3f452bf8df"}],"parent":"64c99878bc4e"},{"id":"3aca8e4a3e4f","title":"整型","children":[{"id":"c76edcc75604","title":"byte(8)","parent":"3aca8e4a3e4f","children":[]},{"id":"7b1008947e9e","title":"&nbsp;char(16)","children":[],"parent":"3aca8e4a3e4f"},{"id":"9a50ea5105db","title":"short(16)","parent":"3aca8e4a3e4f","children":[]},{"id":"8b34ad006c70","title":"int(32)&nbsp;","parent":"3aca8e4a3e4f","children":[]},{"id":"fffc02910cc4","title":"long(64)","parent":"3aca8e4a3e4f","children":[]}],"parent":"64c99878bc4e"},{"id":"6b8afe94331c","title":"浮点型","children":[{"id":"67a719681881","title":"&nbsp;float(32)","children":[],"parent":"6b8afe94331c"},{"id":"9965aa3c25a9","title":"double(64)","children":[],"parent":"6b8afe94331c"}],"parent":"64c99878bc4e"},{"id":"daa67d091b3b","title":"转换规则","parent":"64c99878bc4e","children":[{"id":"e830898723f2","title":"隐式转换","parent":"daa67d091b3b","children":[{"id":"f22ab32475a2","title":"当一个数值精度小的数转换为一个数值精度大的数时,JVM会进行自动转换,如int转换为long","children":[],"parent":"e830898723f2"}]},{"id":"a3fe15a3f130","title":"显示转换","parent":"daa67d091b3b","children":[{"id":"0c7dc842d466","title":"当数值精度大的数转换为数值精度小的数时,需要显式转换.因为数值在java中是由二进制补码表示的,如果自动截断的话,会使精度丢失,甚至会使一个数由正数变成负数","children":[],"parent":"a3fe15a3f130"}]},{"id":"51fc03f78ced","title":"其他","children":[{"id":"688c018324a5","title":"因为char是无符号的,所以不可以和byte和short发生隐式的自动转换","children":[],"parent":"51fc03f78ced"},{"id":"1910ca6da9b9","title":"对于默认类型为int的值,如果一个int类型的值的大小不超过该类型的数值范围,也会发生隐式转换,如byte a=127;","children":[],"parent":"51fc03f78ced"},{"id":"9e081969f83a","title":"进行数值运算时,如果有double的话,则全部转换为double,顺序依次是double,float,long,否则的话,都会转换为int","children":[],"parent":"51fc03f78ced"}],"parent":"daa67d091b3b"}]}],"parent":"root"},{"id":"96c65b3ae244","title":"Socket","parent":"root","children":[{"id":"e78f9012e882","title":"ServerSocket","children":[],"parent":"96c65b3ae244"},{"id":"4c45699f7624","title":"Socket","children":[],"parent":"96c65b3ae244"}]},{"id":"eda5863f37cb","title":"JDBC","parent":"root","children":[{"id":"71f38c94c726","title":"DriverManager","children":[],"parent":"eda5863f37cb"},{"id":"fca2987c0589","title":"Connection","children":[],"parent":"eda5863f37cb"},{"id":"d60f24190183","title":"Statement","children":[],"parent":"eda5863f37cb"},{"id":"8761302c708b","title":"ResultSet","children":[],"parent":"eda5863f37cb"}]},{"id":"8b57dc6ad458","title":"异常","parent":"root","children":[{"id":"6db234753c96","title":"Throwable","children":[{"id":"3b015a3332a7","title":"Error","children":[{"id":"057822b8ed27","title":"程序解决不了的问题,一般是底层系统出错,或者是内存不够等","parent":"3b015a3332a7","children":[]}],"parent":"6db234753c96"},{"id":"623237574197","title":"Exception&nbsp;","children":[{"id":"cf5211f4fc71","title":"运行时异常","parent":"623237574197","children":[{"id":"5c699e8833d7","title":"NullPointerException,ClassNotFoundException","parent":"cf5211f4fc71","children":[]}]},{"id":"e7fdeac7cda8","title":"已检查异常","parent":"623237574197","children":[{"id":"b339e9dacba2","title":"必须手动抛出,常见的有IOException,InterruptedException,SocketException","parent":"e7fdeac7cda8","children":[]},{"id":"1c60db41bd99","title":"抛出的方式有throw和throws","parent":"e7fdeac7cda8","children":[]}]}],"parent":"6db234753c96"}],"parent":"8b57dc6ad458"}]},{"id":"ff2a577d1927","title":"JVM","parent":"root","children":[]},{"id":"d9a1f993b825","title":"容器","parent":"root","children":[]}],"structure":"mind_free","root":true,"theme":"colorLines","children":[{"id":"6e67d4462b7a","title":"Object","children":[{"id":"c599064b40f3","title":"equals","children":[{"id":"417dd5b98932","title":"&nbsp;\"==\"和equals()的区别:对于基本数据类型,两者的作用是一致的,但是对于引用数据类型,\"==\"比较的是两个对象的引用是否相同,而equals比较的是两个对象的值是否相同,.当然在底层事项中,equals也是用的\"==\",只是在具体的类型中,重写了该方法","children":[],"parent":"c599064b40f3"}],"parent":"6e67d4462b7a"},{"id":"6fa8acd5b414","title":"hashcode","parent":"6e67d4462b7a","children":[{"id":"f6df6a14fa96","title":"根据对象地址用hash算法转换而来,用来比较两个对象的引用是否相同.但两个对象的hashcode相同,并不一定代表就是同一个对象,因为会发生hash碰撞","parent":"6fa8acd5b414","children":[]}]},{"id":"0f271e278265","title":"wait()","children":[{"id":"565cf5a8a06b","title":"在多线程中,可以停止当前线程,会释放当前持有的锁.释放后,进入等待队列,等待notify和notifyAll方法唤醒,唤醒后进入竞争队列,等待获取锁","parent":"0f271e278265","children":[]}],"parent":"6e67d4462b7a"},{"id":"1dcbba79679f","title":"clone","parent":"6e67d4462b7a","children":[{"id":"6162cccfc927","title":"用来拷贝.需要实现Cloneable接口,并在子类中重写clone方法.这只是浅拷贝,只会拷贝类中的基本变量,而类中的由其他类实现的成员变量则没有拷贝","parent":"1dcbba79679f","children":[]}]},{"id":"0e5aa7b94ae0","title":"toString()","parent":"6e67d4462b7a","children":[]},{"id":"3882bd55c223","title":"finalize()","children":[{"id":"871cd113e3d9","title":"在进行GC回收时,会执行.执行过后,并一定会真的被回收,如果在GC前,重新获得了引用,则可以不被回收,但这个方法只会执行一次","parent":"3882bd55c223","children":[]}],"parent":"6e67d4462b7a"}],"parent":"root"},{"id":"3fcb87061875","title":"序列化和反序列化","children":[{"id":"fad154c46f31","title":"Serializable","children":[{"id":"c108a80d12dd","title":"只是一个标识,没有具体的方法实现或属性","parent":"fad154c46f31","children":[]}],"parent":"3fcb87061875"},{"id":"092d096dd837","title":"Externalizable","children":[{"id":"40431a4fa55a","title":"需要重写方法writeExternal()和readExternal(),如果不重写的话,对象的状态无法保存下来,而是初值","parent":"092d096dd837","children":[]}],"parent":"3fcb87061875"},{"id":"1832e9de5e53","title":"transient","parent":"3fcb87061875","children":[{"id":"95d25664f34d","title":"可以使对象不被序列化","parent":"1832e9de5e53","children":[]}]},{"id":"4d844b62fe53","title":"ObjectInputStream(),ObjectOutputStream()","parent":"3fcb87061875","children":[]},{"id":"b8d739d1f9be","title":"序列化id","parent":"3fcb87061875","children":[{"id":"b6839f1f0b9c","title":"一个对象想要反序列化,必须要保证序列化id与原对象的相同","parent":"b8d739d1f9be","children":[]}]},{"id":"b519034b092e","title":"静态变量不能序列化","children":[],"parent":"3fcb87061875"}],"parent":"root"},{"id":"1f020a2925b8","title":"String类和相关类","parent":"root","children":[{"id":"2d5a049b4666","title":"String","children":[{"id":"aa2e6ce48bdf","title":"用final修饰,所以不可以被改变,如果是用字面量来创建的话保存在常量池中","parent":"2d5a049b4666","children":[]}],"parent":"1f020a2925b8"},{"id":"f154510a58c5","title":"StringBuilder","children":[{"id":"a6c481c02fc1","title":"可以修改,但是是线程不安全的","children":[],"parent":"f154510a58c5"}],"parent":"1f020a2925b8"},{"id":"d47279650787","title":"StringBuffer","children":[{"id":"0c50152821ed","title":"可以修改,是线程安全的,但在单线程环境下,因为有锁消除,所以效率并没有真正的降低","children":[],"parent":"d47279650787"}],"parent":"1f020a2925b8"}]},{"id":"43632589c264","title":"反射","children":[{"id":"37c9d50ced39","title":"创建对象的三种方式","parent":"43632589c264","children":[{"id":"7ce4b05da7e4","title":"Person p=new Person();&nbsp; &nbsp; &nbsp; &nbsp;Class test1=p.getClass();<br>","parent":"37c9d50ced39","children":[]},{"id":"7f90cec19fe2","title":"Class test2=Person.class;","children":[],"parent":"37c9d50ced39"},{"id":"a71cc47d15d5","title":"Class test3=Class.forName(java.test.Person);","children":[],"parent":"37c9d50ced39"}]},{"id":"6813e74c3b54","title":"方法:getFields(),getConstructors(),getMethod().","parent":"43632589c264","children":[{"id":"19dd1e6e77a1","title":"如果是私有的方法或属性的话,需要设置setAccessable(true),然后用getDeclaredMethod()访问","parent":"6813e74c3b54","children":[]}]}],"parent":"root"},{"id":"2c2fa199a15f","title":"面向对象","parent":"root","children":[{"id":"a4a81b240808","title":"继承","parent":"2c2fa199a15f","children":[{"id":"0b07fc01e65c","title":"抽象类","children":[{"id":"e2e493ab306c","title":"有抽象方法的一定是抽象类,抽象类中可以有方法的具体实现","children":[],"parent":"0b07fc01e65c"},{"id":"8e90a9a5093e","title":"抽象类中的方法和属性可以有其他修饰符修饰","children":[],"parent":"0b07fc01e65c"},{"id":"ac0e41c1f639","title":"类只能单继承","children":[],"parent":"0b07fc01e65c"},{"id":"9ce2b24598e9","title":"不能创建抽象类的实例","children":[],"parent":"0b07fc01e65c"}],"parent":"a4a81b240808"},{"id":"0a0d9497493d","title":"接口","children":[{"id":"23032bd8b08c","title":"接口中一定不能有方法的具体实现","children":[],"parent":"0a0d9497493d"},{"id":"55e74605cc8c","title":"接口的属性默认是public static final的,方法默认是public final abstract的","children":[],"parent":"0a0d9497493d"},{"id":"ca3dbae3af6f","title":"接口可以多实现","children":[],"parent":"0a0d9497493d"}],"parent":"a4a81b240808"}]},{"id":"c7ff5d2fbda7","title":"封装","parent":"2c2fa199a15f","children":[{"id":"8fc6b37faed0","title":"public&nbsp;","parent":"c7ff5d2fbda7","children":[]},{"id":"a9c32bdceac8","title":"protected","children":[{"id":"5564319e5f5e","title":"同一包内和子类中,但与父类不在同一包中的子类,只能访问从父类继承而来的受保护成员,而不能访问父类本身的受保护成员","parent":"a9c32bdceac8","children":[]}],"parent":"c7ff5d2fbda7"},{"id":"eacd37f3a1b1","title":"default","parent":"c7ff5d2fbda7","children":[{"id":"dd2d138d8f07","title":"没有修饰符的情况,同一包内可以访问","parent":"eacd37f3a1b1","children":[]}]},{"id":"6ea729b227b4","title":"private","parent":"c7ff5d2fbda7","children":[]}]},{"id":"25663b7d8ffd","title":"多态","parent":"2c2fa199a15f","children":[{"id":"40868c8c8191","title":"重写","parent":"25663b7d8ffd","children":[{"id":"288c906d610a","title":"子类继承父类的方法","parent":"40868c8c8191","children":[]}]},{"id":"9cd3239fd98b","title":"重载","parent":"25663b7d8ffd","children":[{"id":"ac99b04d696c","title":"方法参数的类型或数量不同,才算是真正的重载 返回的参数类型不同,并不能算是重载","parent":"9cd3239fd98b","children":[]}]}]}]},{"id":"c336dce7b5e1","title":"内部类","parent":"root","children":[{"id":"8bfdbb24889a","title":"分类","parent":"c336dce7b5e1","children":[{"id":"eba8c4244bb4","title":"成员内部类","children":[],"parent":"8bfdbb24889a"},{"id":"8edbb18a7fcb","title":"方法内部类","children":[],"parent":"8bfdbb24889a"},{"id":"f8d98bfcc404","title":"匿名方法类","children":[{"id":"816a28796eb3","title":"常来用实现接口中只有一个方法的情况,如java Applet中的事件类","children":[],"parent":"f8d98bfcc404"}],"parent":"8bfdbb24889a"},{"id":"b16b24e0c10e","title":"静态内部类","children":[{"id":"50d1506597b1","title":"静态内部类只能访问外部类中的静态成员","children":[],"parent":"b16b24e0c10e"}],"parent":"8bfdbb24889a"}]},{"id":"3f83c367eeb8","title":"内涵","children":[{"id":"b9710469625a","title":"内部类持有外部类的一个引用,可以访问外部类的所有属性和方法,但外部类不能访问","children":[],"parent":"3f83c367eeb8"}],"parent":"c336dce7b5e1"},{"id":"d7549c420619","title":"JVM并没有内部类的概念,创建好后是Outter.class$Intter.class这样的形式","children":[],"parent":"c336dce7b5e1"}]},{"id":"fbb481b6628b","free":true,"title":"自由主题","children":[],"parent":"root","pos":{"y":9998,"x":8365}},{"id":"ec6e64cce53c","title":"linuxIO模型","free":true,"parent":"root","children":[{"id":"067368c2fa05","title":"堵塞IO","children":[{"id":"72068f7613ca","title":"在用户空间中调用recvform,其系统调用直到数据包到达,并且被复制到应用程序的缓冲区中或者发生错误才会被返回,在此期间一直在等待","parent":"067368c2fa05","children":[]}],"parent":"ec6e64cce53c"},{"id":"df3ef9b7298b","title":"非堵塞IO&nbsp;","parent":"ec6e64cce53c","children":[{"id":"81f24519d844","title":"recvform在从用户态到内核态的过程中,如果没有数据进行传输,会返回一个错误,一般非堵塞IO模型会轮询这个状态,看内核是不是有数据","children":[],"parent":"df3ef9b7298b"}]},{"id":"9cf99dd60df0","title":"IO多路复用","parent":"ec6e64cce53c","children":[{"id":"75e374fea79d","title":"原理:通过一种机制能实现一个进程同时等待多个文件描述符","children":[],"parent":"9cf99dd60df0"},{"id":"07341f0b306c","title":"select","children":[{"id":"31e3fbe3d907","title":"有大小限制,需要轮询,,需要每次进行判断时拷贝全部FD","children":[],"parent":"07341f0b306c"}],"parent":"9cf99dd60df0"},{"id":"a8de9ac06fdc","title":"poll","children":[{"id":"c02eebd8660e","title":"没有大小限制,仍然需要每次拷贝全部FD,需要轮询","children":[],"parent":"a8de9ac06fdc"}],"parent":"9cf99dd60df0"},{"id":"4ae13518f011","title":"epoll","children":[{"id":"f2d677d66913","title":"epoll_create","parent":"4ae13518f011","children":[{"id":"9f8f0df076b3","title":"建立一颗红黑树","children":[],"parent":"f2d677d66913"}]},{"id":"a7f7a5343a24","title":"epoll_Ctl","parent":"4ae13518f011","children":[{"id":"5a3c53101f19","title":"将所有文件描述符全部拷贝到内核态中,只需拷贝一次,且没有大小限制","children":[],"parent":"a7f7a5343a24"}]},{"id":"0bd111503b37","title":"epoll_wait","parent":"4ae13518f011","children":[{"id":"5ed7ef5cf0c2","title":"为有事件发送的FD创建一个回调函数,通过回调函数来实现内核将数据拷贝到用户缓冲区的任务","children":[],"parent":"0bd111503b37"}]}],"parent":"9cf99dd60df0"}]},{"id":"9e9356019db4","title":"信号驱动IO&nbsp;","children":[{"id":"1aec7d760a75","title":"有内核来通知什么时候可以进行IO操作","children":[],"parent":"9e9356019db4"}],"parent":"ec6e64cce53c"},{"id":"329131594cbb","title":"异步IO","parent":"ec6e64cce53c","children":[{"id":"5e50bdc05cc6","title":"用户进程发起read操作后,可以马上去做其他事情,内核会把数据copy到用户内存后返回一个signal,通知read操作完成","children":[],"parent":"329131594cbb"}]}],"pos":{"y":9254.5,"x":8695.5625}}],"lines":{}}},"meta":{"id":"5c94c57de4b0ab74ece2cec4","member":"5c94c2a6e4b02ce2e8992267","exportTime":"2019-12-03 20:02:41","diagramInfo":{"category":"mind_free","title":"java基础","created":"2019-03-22 19:22:37","creator":"5c94c2a6e4b02ce2e8992267","modified":"2019-03-24 15:28:19"},"type":"ProcessOn Schema File","version":"1.0"}}