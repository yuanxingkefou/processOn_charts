{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","title":"JVM","leftChildren":[{"id":"9b830e1b4824","title":"GC","children":[{"id":"d0ceb6cfe271","title":"判断对象是否可被回收","children":[{"id":"2a07752a99a9","title":"引用计数器算法","children":[{"id":"31b57472a200","title":"解决不了相互引用的问题","children":[],"parent":"2a07752a99a9"}],"parent":"d0ceb6cfe271"},{"id":"421532066448","title":"可达性分析算法","children":[],"parent":"d0ceb6cfe271"}],"parent":"9b830e1b4824"},{"id":"5bf8e916b255","title":"GC算法","parent":"9b830e1b4824","children":[{"id":"771a263e8de2","title":"标记-清除算法","parent":"5bf8e916b255","children":[]},{"id":"876ec48e0a3f","title":"复制算法","parent":"5bf8e916b255","children":[]},{"id":"3cf64872e92a","title":"标记-整理算法","parent":"5bf8e916b255","children":[]},{"id":"930845b4580a","title":"分代算法","parent":"5bf8e916b255","children":[]}]},{"id":"fbbc6fac985a","title":"GC收集器","children":[{"id":"f4e1e4f33e30","title":"Serial","children":[{"id":"f61deca97d3f","title":"单线程环境，年轻代，采用复制算法","children":[],"parent":"f4e1e4f33e30"}],"parent":"fbbc6fac985a"},{"id":"b8bfeb2e6155","title":"Serial Old","children":[{"id":"94f1a24c8198","title":"单线程环境，老年代，采用标记-整理算法","children":[],"parent":"b8bfeb2e6155"}],"parent":"fbbc6fac985a"},{"id":"4bedd48124d5","title":"parNew","children":[{"id":"8d6a78e0e6d6","title":"Serial的多线程版本","children":[],"parent":"4bedd48124d5"}],"parent":"fbbc6fac985a"},{"id":"97c8ce4e1dc7","title":"parallel Scavenge","parent":"fbbc6fac985a","children":[{"id":"dfb925ed8c34","title":"目的是达到可控吞吐量，适合后台运算而不需要太多交互的系统","parent":"97c8ce4e1dc7","children":[]}]},{"id":"e27865640109","title":"parallel Old","children":[{"id":"7bb216508b7b","title":"parNew对应的老年代版本","parent":"e27865640109","children":[]}],"parent":"fbbc6fac985a"},{"id":"82a4f5d7692c","title":"G1","children":[{"id":"39a443c0317d","title":"寻求吞吐量和最短停顿时间兼容的版本","parent":"82a4f5d7692c","children":[{"id":"604ad66f7aae","title":"步骤","parent":"39a443c0317d","children":[{"id":"e40bdbd380e9","title":"首次标记","parent":"604ad66f7aae","children":[]},{"id":"312324afda6c","title":"并发标记","parent":"604ad66f7aae","children":[]},{"id":"ddf6e316156e","title":"重新标记","parent":"604ad66f7aae","children":[]},{"id":"903554fab5b5","title":"标记整理","parent":"604ad66f7aae","children":[]}]}]}],"parent":"fbbc6fac985a"},{"id":"960f8e2f9f98","title":"CMS","parent":"fbbc6fac985a","children":[{"id":"0aace7f9c2e9","title":"更看重最短停顿时间","parent":"960f8e2f9f98","children":[]}]}],"parent":"9b830e1b4824"},{"id":"4c6cf1a4860c","title":"具体过程","parent":"9b830e1b4824","children":[{"id":"699cea165ee7","title":"年轻代会进行Mnior GC，将Eden区和一个Survivor区中可以进行回收的内存进行回收，不能回收的放在另一个Survivor区中，同时进行计数，如果计数值已经达到年老区的值（默认为15），则将其放到Old区中，另外，对于一些占用比较大内存的对象，如大的数组，长的字符串都会直接放入年老区中&nbsp;","parent":"4c6cf1a4860c","children":[]}]}],"parent":"root"},{"id":"238e4fad4d33","title":"JVM调优","parent":"root","children":[{"id":"15309d9ffa15","title":"常用工具","parent":"238e4fad4d33","children":[{"id":"0a9e3f89575e","title":"JConsole","parent":"15309d9ffa15","children":[]},{"id":"1cc5fb59a37e","title":"VisualVM","parent":"15309d9ffa15","children":[]}]},{"id":"830b12efe172","title":"常用命令","parent":"238e4fad4d33","children":[{"id":"1e7fde5fe906","title":"jps：显示所有进程","parent":"830b12efe172","children":[]},{"id":"1fb6858c9bef","title":"jstat：显示虚拟机各方面的运行数据","parent":"830b12efe172","children":[]},{"id":"ed3d57a43063","title":"等","parent":"830b12efe172","children":[]}]}]}],"structure":"mind_free","root":true,"theme":"colorLines","children":[{"id":"b6fd67491e12","title":"JMM","parent":"root","children":[{"id":"c2efcc3f2e44","title":"内存屏障","children":[],"parent":"b6fd67491e12"},{"id":"bf6d0b34c2df","title":"happen-before机制","children":[],"parent":"b6fd67491e12"}]},{"id":"b7b718081d70","title":"运行时数据区","parent":"root","children":[{"id":"32726dde146a","title":"堆","parent":"b7b718081d70","children":[{"id":"39a4a9d17569","title":"用来存放具体的对象，当请求的堆的大小超过了规定的大小时，会发生OOM异常","parent":"32726dde146a","children":[]}]},{"id":"f21c3f00adbe","title":"虚拟方法栈","parent":"b7b718081d70","children":[{"id":"dd794c16013e","title":"用来存放对象的引用，每个方法都会有一个栈帧，里面有本地变量表等。当请求的栈的深度超过了规定的栈的深度，会发生StackOverflow异常。如果栈支持自动扩展，但没有扩展可用的内存，会发生OOM异常","parent":"f21c3f00adbe","children":[]}]},{"id":"232d244962f1","title":"本地方法栈","parent":"b7b718081d70","children":[{"id":"637a162d6bde","title":"同上","parent":"232d244962f1","children":[]}]},{"id":"776acd0c4ab3","title":"程序计数器","parent":"b7b718081d70","children":[]},{"id":"14ecee6f5073","title":"运行时常量池","parent":"b7b718081d70","children":[{"id":"eea7f7170c10","title":"会抛出OOM异常","parent":"14ecee6f5073","children":[]}]},{"id":"1ba41931df24","title":"方法区","parent":"b7b718081d70","children":[{"id":"ff787eff4adc","title":"会抛出OOM异常","parent":"1ba41931df24","children":[]}]}]},{"id":"6862c29e2fb9","title":"类加载机制","children":[{"id":"18bdbd796f70","title":"原理","parent":"6862c29e2fb9","children":[{"id":"874b860a240a","title":"双亲委派机制","parent":"18bdbd796f70","children":[{"id":"f7f3e64b1ec6","title":"BootStrap ClassLoader","parent":"874b860a240a","children":[]},{"id":"627bc0916ac1","title":"External ClassLoader","parent":"874b860a240a","children":[]},{"id":"86a3dbcef015","title":"Application ClassLoader","parent":"874b860a240a","children":[]}]},{"id":"af94626f22ce","title":"打破双亲委派机制","parent":"18bdbd796f70","children":[{"id":"7cf3cc5b924e","title":"自定义编译器，重写方法","parent":"af94626f22ce","children":[]}]}]},{"id":"aee67657ab32","title":"过程","parent":"6862c29e2fb9","children":[{"id":"46bc523df274","title":"加载","parent":"aee67657ab32","children":[{"id":"4b606ddcf885","title":"在工作区生成一个Class对象，将Java源码转换为字节码","parent":"46bc523df274","children":[]}]},{"id":"82bf87dcc64c","title":"链接","parent":"aee67657ab32","children":[{"id":"fa99acd5276f","title":"验证","parent":"82bf87dcc64c","children":[{"id":"c4af712150d9","title":"对字节码进行安全性的验证","parent":"fa99acd5276f","children":[]}]},{"id":"ecc7c148a01f","title":"准备","parent":"82bf87dcc64c","children":[{"id":"98bdd67a7311","title":"为类变量分配内存和初值","parent":"ecc7c148a01f","children":[]}]},{"id":"429c4bd6744b","title":"解析","parent":"82bf87dcc64c","children":[{"id":"9672c990bf14","title":"将常量池中的符号引用转换为直接引用","parent":"429c4bd6744b","children":[]}]}]},{"id":"26352bc38287","title":"初始化","parent":"aee67657ab32","children":[{"id":"b561a7254ea3","title":"执行&lt;clinit&gt;方法，初始化静态变量","parent":"26352bc38287","children":[{"id":"61f7047ee028","title":"类的主动引用（有五种情况需要必须立即对类进行初始化）","parent":"b561a7254ea3","children":[{"id":"61c3ec3b342a","title":"1.遇到new,getStatic,putstatic,invokestatic这四条指令时","parent":"61f7047ee028","children":[]},{"id":"2af655906292","title":"2.使用java.lang.reflect包的方法进行反射调用","parent":"61f7047ee028","children":[]},{"id":"545a92729999","title":"3.当初始化一个类时，如果它的父类还没有进行初始化，则需要先初始化它的父类","parent":"61f7047ee028","children":[]},{"id":"f5d340a263c0","title":"4.当虚拟机要启动一个类时，用户指定一个要执行的主类，虚拟机会初始化这个主类","parent":"61f7047ee028","children":[]},{"id":"15199e70c292","title":"5.当使用jdk1.7中的动态语言支持时，最后解析出来的结果是REF_getstatic ,REF_putstatic,REF_invokestaic的方法句柄时","parent":"61f7047ee028","children":[]}]},{"id":"b6f327a45e44","title":"被动引用","parent":"b561a7254ea3","children":[{"id":"1328f8198ced","title":"通过子类引用父类的静态字段","parent":"b6f327a45e44","children":[]},{"id":"8e6ce7d29f63","title":"通过数组来定义类","parent":"b6f327a45e44","children":[]},{"id":"9e0ac853ef56","title":"常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，不会初始化","parent":"b6f327a45e44","children":[]}]}],"summaries":[]}]}]}],"parent":"root","collapsed":false},{"id":"50ae44573ff9","free":true,"title":"引用类型","children":[{"id":"808c2217d61f","title":"强引用","children":[{"id":"20e5980dc4b7","title":"GC中不会被回收","children":[],"parent":"808c2217d61f"}],"parent":"50ae44573ff9"},{"id":"1b564e1bc103","title":"软引用","children":[{"id":"bdc8f833bdc2","title":"当已经进行过GC后，内存仍然不够，会选择进行回收","children":[],"parent":"1b564e1bc103"}],"parent":"50ae44573ff9"},{"id":"dadfd97420b3","title":"弱引用","children":[{"id":"091b1bcabb6c","title":"在下一次GC时，一定会进行回收","children":[],"parent":"dadfd97420b3"}],"parent":"50ae44573ff9"},{"id":"f1d3e8546b10","title":"虚引用","children":[{"id":"edfe9152596f","title":"没有实际意义，只是用来进行一次标识","children":[],"parent":"f1d3e8546b10"}],"parent":"50ae44573ff9"}],"parent":"root","pos":{"y":10368.650207519531,"x":9876.025390625}}]}},"meta":{"id":"5c957f1ee4b0d1a5b1092dc8","member":"5c94c2a6e4b02ce2e8992267","exportTime":"2019-12-03 20:03:34","diagramInfo":{"category":"mind_free","title":"JVM","created":"2019-03-23 08:34:38","creator":"5c94c2a6e4b02ce2e8992267","modified":"2019-03-23 09:15:48"},"type":"ProcessOn Schema File","version":"1.0"}}